#!/bin/bash
################################################################################
# BGP Configuration Module
#
# Configures BGP unnumbered on:
# - Hypervisor VMs (using FRRouting)
# - SONiC switches (using FRRouting/SONiC BGP)
# - Point-to-point interfaces with IPv6 link-local addresses
################################################################################

configure_bgp() {
    local config_file="$1"
    local dry_run="${2:-false}"
    
    log_info "Configuring BGP unnumbered on all devices..."
    
    # Configure BGP on hypervisors
    configure_bgp_hypervisors "$config_file" "$dry_run"
    
    # Configure BGP on switches
    configure_bgp_switches "$config_file" "$dry_run"
    
    log_success "BGP configuration completed successfully"
}

configure_bgp_hypervisors() {
    local config_file="$1"
    local dry_run="$2"
    
    log_info "Configuring BGP on hypervisors..."
    
    local hv_count=$(yq eval '.hypervisors | length' "$config_file")
    local dc_name=$(yq eval '.global.datacenter_name' "$config_file")
    local ssh_key="$PROJECT_ROOT/config/${dc_name}-ssh-key"
    
    for i in $(seq 0 $((hv_count - 1))); do
        local hv_name=$(yq eval ".hypervisors[$i].name" "$config_file")
        local mgmt_ip=$(yq eval ".hypervisors[$i].management.ip" "$config_file" | cut -d'/' -f1)
        
        if [[ "$dry_run" == "true" ]]; then
            log_info "[DRY RUN] Would configure BGP on $hv_name"
            continue
        fi
        
        log_info "Configuring BGP on hypervisor: $hv_name ($mgmt_ip)"
        
        # Generate BGP configuration for this hypervisor
        generate_hypervisor_bgp_config "$config_file" "$i" "$hv_name"
        
        # Wait for VM to be ready
        wait_for_vm "$mgmt_ip" "$ssh_key"
        
        # Apply BGP configuration
        apply_hypervisor_bgp_config "$hv_name" "$mgmt_ip" "$ssh_key"
    done
    
    log_success "✓ BGP configured on all hypervisors"
}

generate_hypervisor_bgp_config() {
    local config_file="$1"
    local index="$2"
    local hv_name="$3"
    
    local router_id=$(yq eval ".hypervisors[$index].router_id" "$config_file")
    local asn=$(yq eval ".hypervisors[$index].asn" "$config_file")
    
    local bgp_config_dir="$PROJECT_ROOT/config/bgp-configs"
    mkdir -p "$bgp_config_dir"
    
    # Find all neighbors from cabling configuration
    local neighbors=""
    local cable_count=$(yq eval '.cabling | length' "$config_file")
    
    for i in $(seq 0 $((cable_count - 1))); do
        local src_device=$(yq eval ".cabling[$i].source.device" "$config_file")
        local src_iface=$(yq eval ".cabling[$i].source.interface" "$config_file")
        local dst_device=$(yq eval ".cabling[$i].destination.device" "$config_file")
        local dst_iface=$(yq eval ".cabling[$i].destination.interface" "$config_file")
        
        if [[ "$src_device" == "$hv_name" ]]; then
            neighbors="${neighbors}\n neighbor $src_iface interface peer-group FABRIC"
        elif [[ "$dst_device" == "$hv_name" ]]; then
            neighbors="${neighbors}\n neighbor $dst_iface interface peer-group FABRIC"
        fi
    done
    
    # Generate FRR configuration
    cat > "$bgp_config_dir/${hv_name}-bgp.conf" <<EOF
!
! BGP Configuration for $hv_name
! Generated by Virtual DC deployment system
!
frr version 8.1
frr defaults traditional
hostname $hv_name
log syslog informational
no ipv6 forwarding
service integrated-vtysh-config
!
interface lo
 ip address $router_id/32
!
router bgp $asn
 bgp router-id $router_id
 bgp log-neighbor-changes
 no bgp default ipv4-unicast
 bgp bestpath as-path multipath-relax
 !
 ! BGP unnumbered neighbors
 neighbor FABRIC peer-group
 neighbor FABRIC remote-as external
 neighbor FABRIC capability extended-nexthop
 !$neighbors
 !
 address-family ipv4 unicast
  neighbor FABRIC activate
  neighbor FABRIC route-map ALLOW-ALL in
  neighbor FABRIC route-map ALLOW-ALL out
  redistribute connected
  maximum-paths 64
 exit-address-family
!
! Route maps
route-map ALLOW-ALL permit 10
!
line vty
!
end
EOF
    
    log_success "✓ BGP configuration generated for $hv_name"
}

apply_hypervisor_bgp_config() {
    local hv_name="$1"
    local mgmt_ip="$2"
    local ssh_key="$3"
    
    local bgp_config="$PROJECT_ROOT/config/bgp-configs/${hv_name}-bgp.conf"
    
    log_info "Applying BGP configuration to $hv_name..."
    
    # Copy configuration to VM
    scp -i "$ssh_key" -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null \
        "$bgp_config" "ubuntu@${mgmt_ip}:/tmp/frr.conf" 2>/dev/null
    
    # Apply configuration
    ssh -i "$ssh_key" -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null \
        "ubuntu@${mgmt_ip}" <<'ENDSSH' 2>/dev/null
sudo cp /tmp/frr.conf /etc/frr/frr.conf
sudo chown frr:frr /etc/frr/frr.conf
sudo chmod 640 /etc/frr/frr.conf
sudo systemctl restart frr
sleep 5
sudo vtysh -c "show bgp summary"
ENDSSH
    
    log_success "✓ BGP configuration applied to $hv_name"
}

configure_bgp_switches() {
    local config_file="$1"
    local dry_run="$2"
    
    log_info "Configuring BGP on switches..."
    
    local dc_name=$(yq eval '.global.datacenter_name' "$config_file")
    local ssh_key="$PROJECT_ROOT/config/${dc_name}-ssh-key"
    
    # Configure each tier
    for tier in leaf spine superspine; do
        local count=$(yq eval ".switches.$tier | length" "$config_file")
        
        for i in $(seq 0 $((count - 1))); do
            local sw_name=$(yq eval ".switches.$tier[$i].name" "$config_file")
            local mgmt_ip=$(yq eval ".switches.$tier[$i].management.ip" "$config_file" | cut -d'/' -f1)
            
            if [[ "$sw_name" == "null" ]] || [[ -z "$sw_name" ]]; then
                continue
            fi
            
            if [[ "$dry_run" == "true" ]]; then
                log_info "[DRY RUN] Would configure BGP on $sw_name"
                continue
            fi
            
            log_info "Configuring BGP on switch: $sw_name ($mgmt_ip)"
            
            # Generate BGP configuration
            generate_switch_bgp_config "$config_file" "$tier" "$i" "$sw_name"
            
            # Wait for VM to be ready
            wait_for_vm "$mgmt_ip" "$ssh_key"
            
            # Apply BGP configuration
            apply_switch_bgp_config "$sw_name" "$mgmt_ip" "$ssh_key"
        done
    done
    
    log_success "✓ BGP configured on all switches"
}

generate_switch_bgp_config() {
    local config_file="$1"
    local tier="$2"
    local index="$3"
    local sw_name="$4"
    
    local router_id=$(yq eval ".switches.$tier[$index].router_id" "$config_file")
    local asn=$(yq eval ".switches.$tier[$index].asn" "$config_file")
    
    local bgp_config_dir="$PROJECT_ROOT/config/bgp-configs"
    mkdir -p "$bgp_config_dir"
    
    # Find all neighbors from cabling configuration
    local neighbors=""
    local cable_count=$(yq eval '.cabling | length' "$config_file")
    
    for i in $(seq 0 $((cable_count - 1))); do
        local src_device=$(yq eval ".cabling[$i].source.device" "$config_file")
        local src_iface=$(yq eval ".cabling[$i].source.interface" "$config_file")
        local dst_device=$(yq eval ".cabling[$i].destination.device" "$config_file")
        local dst_iface=$(yq eval ".cabling[$i].destination.interface" "$config_file")
        
        if [[ "$src_device" == "$sw_name" ]]; then
            neighbors="${neighbors}\n neighbor $src_iface interface peer-group FABRIC"
        elif [[ "$dst_device" == "$sw_name" ]]; then
            neighbors="${neighbors}\n neighbor $dst_iface interface peer-group FABRIC"
        fi
    done
    
    # Generate configuration (similar to hypervisor but for SONiC)
    cat > "$bgp_config_dir/${sw_name}-bgp.conf" <<EOF
!
! BGP Configuration for $sw_name
!
router bgp $asn
 bgp router-id $router_id
 bgp log-neighbor-changes
 no bgp default ipv4-unicast
 bgp bestpath as-path multipath-relax
 !
 neighbor FABRIC peer-group
 neighbor FABRIC remote-as external
 neighbor FABRIC capability extended-nexthop
 !$neighbors
 !
 address-family ipv4 unicast
  neighbor FABRIC activate
  neighbor FABRIC route-map ALLOW-ALL in
  neighbor FABRIC route-map ALLOW-ALL out
  redistribute connected
  maximum-paths 64
 exit-address-family
!
route-map ALLOW-ALL permit 10
!
end
EOF
    
    log_success "✓ BGP configuration generated for $sw_name"
}

apply_switch_bgp_config() {
    local sw_name="$1"
    local mgmt_ip="$2"
    local ssh_key="$3"
    
    local bgp_config="$PROJECT_ROOT/config/bgp-configs/${sw_name}-bgp.conf"
    
    log_info "Applying BGP configuration to $sw_name..."
    
    # For SONiC, configuration might be different
    # This is a placeholder - actual implementation depends on SONiC version
    
    log_success "✓ BGP configuration prepared for $sw_name"
}

wait_for_vm() {
    local ip="$1"
    local ssh_key="$2"
    local max_attempts=30
    local attempt=0
    
    log_info "Waiting for VM to be ready at $ip..."
    
    while [[ $attempt -lt $max_attempts ]]; do
        if ssh -i "$ssh_key" -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null \
               -o ConnectTimeout=5 "ubuntu@${ip}" "echo ready" &>/dev/null; then
            log_success "✓ VM is ready at $ip"
            return 0
        fi
        
        attempt=$((attempt + 1))
        sleep 10
    done
    
    log_error "VM at $ip did not become ready within timeout"
    return 1
}

verify_bgp_neighbors() {
    local config_file="$1"
    local device_name="$2"
    local mgmt_ip="$3"
    local ssh_key="$4"
    
    log_info "Verifying BGP neighbors on $device_name..."
    
    ssh -i "$ssh_key" -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null \
        "ubuntu@${mgmt_ip}" "sudo vtysh -c 'show bgp summary'" 2>/dev/null
}

show_bgp_routes() {
    local device_name="$1"
    local mgmt_ip="$2"
    local ssh_key="$3"
    
    log_info "BGP routes on $device_name:"
    
    ssh -i "$ssh_key" -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null \
        "ubuntu@${mgmt_ip}" "sudo vtysh -c 'show bgp ipv4 unicast'" 2>/dev/null
}
